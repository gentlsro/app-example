// Generated by AI :)

export default class SortableRevertPlugin {
  static attachTo(sortable) {
    if (!sortable._revertPlugin) {
      sortable._revertPlugin = new SortableRevertPlugin()
      sortable._revertPlugin._attach(sortable)
    }
  }

  _attach(sortable) {
    let lastMoveState = null

    const originalOnStart = sortable.options.onStart
    const originalOnEnd = sortable.options.onEnd

    sortable.options.onStart = function (evt) {
      if (typeof originalOnStart === 'function') {
        originalOnStart.call(this, evt)
      }
      lastMoveState = {
        item: evt.item,
        fromList: evt.from,
        oldIndex: evt.oldIndex,
        toList: null,
        newIndex: null,
      }
    }

    sortable.options.onEnd = function (evt) {
      if (typeof originalOnEnd === 'function') {
        originalOnEnd.call(this, evt)
      }
      if (
        lastMoveState
        && (evt.from !== evt.to || evt.oldIndex !== evt.newIndex)
      ) {
        lastMoveState.toList = evt.to
        lastMoveState.newIndex = evt.newIndex
      } else {
        lastMoveState = null
      }
    }

    sortable.revertLastMove = function () {
      if (
        !lastMoveState
        || !lastMoveState.item
        || !lastMoveState.fromList
        || !lastMoveState.toList
      ) {
        lastMoveState = null
        return false
      }

      const { item, fromList, oldIndex } = lastMoveState

      // Check if item and fromList are still in the DOM
      if (
        !item.parentNode
        || !fromList.parentNode
        || !lastMoveState.toList.contains(item)
      ) {
        lastMoveState = null
        return false
      }

      const children = fromList.children
      if (oldIndex >= children.length) {
        fromList.appendChild(item)
      } else {
        fromList.insertBefore(item, children[oldIndex])
      }

      lastMoveState = null
      return true
    }
  }
}
